import xml.etree.ElementTree as ET import tkinter as tk from tkinter import filedialog, messagebox, ttk # ----------------------------- # Namespaces (used by parsing) # ----------------------------- ns = { 'scl': 'http://www.iec.ch/61850/2003/SCL', 'geDSA': 'http://www.gegridsolutions.com/DSAgile', 'xsi': 'http://www.w3.org/2001/XMLSchema-instance', 'eGe': 'http://www.ge.com', 'eGE': 'http://www.gedigitalenergy.com/multilin' } ET.register_namespace('', ns['scl']) ET.register_namespace('geDSA', ns['geDSA']) ET.register_namespace('xsi', ns['xsi']) ET.register_namespace('eGe', ns['eGe']) ET.register_namespace('eGE', ns['eGE']) logo_base64 = """ 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 """ # ----------------------------- # The original deletion logic (kept intact) # ----------------------------- def process_xml(input_file, delete_P, delete_UR, ln_classes_to_delete, output_file): """ Remove <LN> elements based on device type + LN class selection. This function keeps your original nested-loop conditions unchanged. Returns number of <LN> elements removed. """ try: tree = ET.parse(input_file) root = tree.getroot() removed_count = 0 # P-type processing if delete_P: for ied in root.findall('scl:IED', ns): ied_type = ied.get("type") if ied_type and ied_type.startswith("P"): for access_point in ied.findall('scl:AccessPoint', ns): for server in access_point.findall('scl:Server', ns): for ldevice in server.findall('scl:LDevice', ns): LD = ldevice.get("inst") if LD in ["System", "Measurements","Prot", "Ctrl", "Master", "Gen", "Meter"]: for ln in list(ldevice.findall('scl:LN', ns)): ln_class = ln.get('lnClass') if ln_class and ln_class in ln_classes_to_delete: ldevice.remove(ln) removed_count += 1 # UR-type processing if delete_UR: for ied in root.findall('scl:IED', ns): ied_type = ied.get("desc") if ied_type == "UR": for access_point in ied.findall('scl:AccessPoint', ns): for server in access_point.findall('scl:Server', ns): for ldevice in server.findall('scl:LDevice', ns): LD = ldevice.get("inst") if LD in ["Prot", "Ctrl", "System", "Master", "Gen"]: for ln in list(ldevice.findall('scl:LN', ns)): ln_class = ln.get('lnClass') if ln_class and ln_class in ln_classes_to_delete: ldevice.remove(ln) removed_count += 1 tree.write(output_file, encoding="UTF-8", xml_declaration=True) return removed_count except Exception as e: raise RuntimeError(f"Error processing {input_file}: {e}") # ----------------------------- # GUI Application # ----------------------------- class LNFilterApp: def __init__(self, root): self.root = root root.title("LN Filter Tool Version 1.0") root.geometry("550x600") root.resizable(False, False) root.configure(bg="white") # theme colors self.primary_color = "#005E60" #self.hover_color = "#007070" self.hover_color = "#005E60" self.disabled_color = "#9bbebe" # a lighter tone for disabled # state self.input_path = tk.StringVar() self.output_path = tk.StringVar() self.delete_P = tk.BooleanVar(value=False) self.delete_UR = tk.BooleanVar(value=False) self.delete_P14 = tk.BooleanVar(value=False) self.lnclass_vars = {} # ln_class -> BooleanVar self.last_ln_count = {} # ln_class -> count (from last scan) self._build_ui() def _build_ui(self): style = ttk.Style(self.root) style.theme_use("clam") style.configure("TFrame", background="white") style.configure("TLabel", background="white", font=("Segoe UI", 10)) style.configure("Header.TLabel", font=("Segoe UI", 12, "bold")) style.configure("TButton", font=("Segoe UI", 10, "bold")) style.map("TButton", background=[("!disabled", self.primary_color), ("active", self.hover_color), ("disabled", self.disabled_color)], foreground=[("!disabled", "white"), ("disabled", "#e0e0e0")]) # --- Scrollable container for entire GUI --- self.canvas = tk.Canvas(self.root, bg="white", highlightthickness=0) self.scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview) self.canvas.configure(yscrollcommand=self.scrollbar.set) self.canvas.pack(side="left", fill="both", expand=True) self.scrollbar.pack(side="right", fill="y") self.container = ttk.Frame(self.canvas, padding=10) self.canvas.create_window((0, 0), window=self.container, anchor="nw") self.container.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))) header_frame = ttk.Frame(self.container) header_frame.grid(column=0, row=0, columnspan=3, sticky="ew") #header_frame.pack_propagate(False) try: self.logo_img = tk.PhotoImage(data=logo_base64) logo_label = tk.Label(header_frame, image=self.logo_img, bg="white") logo_label.pack() except Exception: logo_icon = tk.Canvas(header_frame, width=80, height=40, bg=self.primary_color, highlightthickness=0) logo_icon.create_text(50, 20, text="GE Vernova", fill="white", font=("Segoe UI", 14, "bold")) logo_icon.pack() # --- Step 1: Input --- ttk.Label(self.container, text="Step 1: Select Input XML/CID File", style="Header.TLabel",foreground = self.hover_color,font=("Century Gothic", 10, "bold"),).grid(column=0, row=1, sticky="w", pady=(5, 2)) self.input_entry = ttk.Entry(self.container, textvariable=self.input_path, width=70) self.input_entry.grid(column=0, row=2, columnspan=2, sticky="ew", pady=6) btn_in = tk.Button(self.container, text="Browse", command=self.browse_input, bg=self.primary_color, fg="white", activebackground=self.hover_color) btn_in.grid(column=2, row=2, padx=6, sticky="e") # --- Step 2: Device types (hidden initially) --- ttk.Label(self.container, text="Step 2: Choose device type(s) to process", style="Header.TLabel",foreground = self.hover_color,font=("Century Gothic", 10, "bold"),).grid(column=0, row=3, sticky="w", pady=(12, 2)) self.device_frame = ttk.Frame(self.container) self.device_frame.grid(column=0, row=4, columnspan=3, sticky="w", pady=(0, 6)) self.cb_p = tk.Checkbutton(self.device_frame, text="Pxxx Relay", variable=self.delete_P, bg="white", anchor='w', command=self.on_device_toggle) self.cb_ur = tk.Checkbutton(self.device_frame, text="UR Relay", variable=self.delete_UR, bg="white", anchor='w', command=self.on_device_toggle) #self.cb_p14 = tk.Checkbutton(self.device_frame, text="P14-type elements", variable=self.delete_P14, bg="white", anchor='w', command=self.on_device_toggle) self.device_frame.grid_remove() # --- Step 3: Scan LN classes --- self.scan_btn = tk.Button(self.container, text="Step 3: Scan LN Classes", bg=self.primary_color, fg="white", activebackground=self.hover_color, command=self.scan_ln_classes) self.scan_btn.grid(column=0, row=5, columnspan=3, pady=(12, 8)) self.scan_btn.config(state="disabled") # --- Step 4: LN classes list (scrollable) --- ttk.Label(self.container, text="Step 4: Select the LN classes you want to delete", style="Header.TLabel",font=("Century Gothic", 10, "bold"),foreground = self.hover_color).grid(column=0, row=6, sticky="w", pady=(6, 4)) lnframe = ttk.Frame(self.container, relief="sunken") lnframe.grid(column=0, row=7, columnspan=3, sticky="nsew") lnframe.configure(height=100) self.last_canvas = tk.Canvas(lnframe, height=175, bg="white", highlightthickness=0) self.last_scroll = ttk.Scrollbar(lnframe, orient="vertical", command=self.last_canvas.yview) self.last_inner = ttk.Frame(self.last_canvas) self.last_inner.bind("<Configure>", lambda e: self.last_canvas.configure(scrollregion=self.last_canvas.bbox("all"))) self.last_canvas.create_window((0, 0), window=self.last_inner, anchor="nw") self.last_canvas.configure(yscrollcommand=self.last_scroll.set) self.last_canvas.pack(side="left", fill="both", expand=True) self.last_scroll.pack(side="right", fill="y") # --- Step 5: Output path --- ttk.Label(self.container, text="Step 5: Select Output File Path", style="Header.TLabel",foreground = self.hover_color,font=("Century Gothic", 10, "bold")).grid(column=0, row=8, sticky="w", pady=(12, 2),) self.output_entry = ttk.Entry(self.container, textvariable=self.output_path, width=70) self.output_entry.grid(column=0, row=9, columnspan=2, sticky="ew", pady=6) btn_out = tk.Button(self.container, text="Browse", command=self.browse_output, bg=self.primary_color, fg="white",activebackground=self.hover_color) btn_out.grid(column=2, row=9, sticky="e") # --- Step 6: Run button & status --- self.run_btn = tk.Button(self.container, text="Step 6: Filter", bg=self.primary_color, fg="white", activebackground=self.hover_color, command=self.run_processing, state="disabled") self.run_btn.grid(column=0, row=10, columnspan=3) self.status_label = ttk.Label(self.container, text="Status: Ready", background="white",foreground = "#66B2B0") self.status_label.grid(column=0, row=11, columnspan=3, sticky="w") # set column expand self.container.columnconfigure(0, weight=1) self.container.columnconfigure(1, weight=1) # ----------------------------- # Callbacks and helpers # ----------------------------- def browse_input(self): file = filedialog.askopenfilename(filetypes=[("CID/XML Files", "*.cid *.xml")]) if not file: return self.input_path.set(file) # show device frame and detect device types in file self.device_frame.grid() # hide device checkbuttons then show only the ones present # reset for widget in (self.cb_p, self.cb_ur): try: widget.grid_forget() except Exception: pass self._detect_device_types(file) self.scan_btn.config(state="normal") self.status_label.config(text="Status: Input file loaded. Select device types, then Scan.") def _detect_device_types(self, file_path): """Detect P / UR / P14 presence and show only the matching checkbuttons.""" # reset checkboxes self.delete_P.set(False) self.delete_UR.set(False) #self.delete_P14.set(False) try: tree = ET.parse(file_path) root = tree.getroot() found = set() for ied in root.findall('scl:IED', ns): ied_type = (ied.get("type") or "").strip().upper() ied_desc = (ied.get("desc") or "").strip().upper() # detect P, UR, P14 if ied_type.startswith("P"): found.add("Pxxx") if ied_type == "UR" or ied_desc == "UR": found.add("UR") # place checkbuttons according to detection row = 0 if "Pxxx" in found: self.cb_p.grid(row=row, column=0, sticky="w") row += 1 if "UR" in found: self.cb_ur.grid(row=row, column=0, sticky="w") row += 1 if not found: messagebox.showwarning("No Devices", "No P, UR device types detected in the file.") except Exception as e: messagebox.showerror("XML Parse Error", f"Failed to parse file: {e}") def on_device_toggle(self): """When device types are toggled, clear previous scan results (user must re-scan).""" # clear previous LN list for w in self.last_inner.winfo_children(): w.destroy() self.lnclass_vars.clear() self.last_ln_count.clear() self.validate_run_button() self.status_label.config(text="Status: Device selection changed — please Scan LN classes.") def scan_ln_classes(self): """Scan LN classes using the exact SAME filtering conditions as process_xml. This ensures scan counts equal eventual deletion counts for the displayed LN classes.""" file_path = self.input_path.get() if not file_path: messagebox.showerror("No input", "Please select an input file first.") return if not (self.delete_P.get() or self.delete_UR.get()): messagebox.showerror("No device", "Select at least one device type before scanning.") return # clear previous listing for w in self.last_inner.winfo_children(): w.destroy() self.lnclass_vars.clear() self.last_ln_count.clear() try: tree = ET.parse(file_path) root = tree.getroot() except Exception as e: messagebox.showerror("XML Parse Error", f"Failed to parse file: {e}") return ln_count = {} # mirror process_xml logic exactly (P) if self.delete_P.get(): for ied in root.findall('scl:IED', ns): ied_type = ied.get("type") if ied_type and ied_type.startswith("P"): for access_point in ied.findall('scl:AccessPoint', ns): for server in access_point.findall('scl:Server', ns): for ldevice in server.findall('scl:LDevice', ns): LD = ldevice.get("inst") if LD in ["System", "Measurements"]: for ln in ldevice.findall('scl:LN', ns): ln_class = ln.get('lnClass') if ln_class: ln_count[ln_class] = ln_count.get(ln_class, 0) + 1 # UR if self.delete_UR.get(): for ied in root.findall('scl:IED', ns): ied_type = ied.get("desc") if ied_type == "UR": for access_point in ied.findall('scl:AccessPoint', ns): for server in access_point.findall('scl:Server', ns): for ldevice in server.findall('scl:LDevice', ns): LD = ldevice.get("inst") if LD in ["Prot", "Ctrl", "System", "Master", "Gen"]: for ln in ldevice.findall('scl:LN', ns): ln_class = ln.get('lnClass') if ln_class: ln_count[ln_class] = ln_count.get(ln_class, 0) + 1 if not ln_count: messagebox.showinfo("No LN found", "No LN classes matching the selected device types/LD filters were found.") self.status_label.config(text="Status: Scan finished — no deletable LN classes found.") self.validate_run_button() return # store the counts for later verification self.last_ln_count = ln_count.copy() # populate the scrollable list with checkboxes (default: checked) header = ttk.Label(self.last_inner, text="Note: LPHD and RDRE logical nodes are mandatory", background="white", font=("Segoe UI", 10)) header.grid(row=0, column=0, sticky="w", pady=(3, 6)) for i, (ln_class, count) in enumerate(ln_count.items(), start=1): var = tk.BooleanVar(value=True) chk = tk.Checkbutton(self.last_inner, text=f"{ln_class} ( {count} )", variable=var, bg="white", anchor="w", command=self.validate_run_button) chk.grid(row=i, column=0, sticky="w", padx=6, pady=2) self.lnclass_vars[ln_class] = var self.status_label.config(text=f"Status: Scan complete — {sum(ln_count.values())} LN elements found (across {len(ln_count)} LN classes).") self.validate_run_button() def browse_output(self): file = filedialog.asksaveasfilename(defaultextension=".cid", filetypes=[("CID/XML Files", "*.cid *.xml")]) if file: self.output_path.set(file) self.validate_run_button() def validate_run_button(self): """Enable Run only when all steps are done.""" input_ok = bool(self.input_path.get()) output_ok = bool(self.output_path.get()) device_ok = (self.delete_P.get() or self.delete_UR.get() or self.delete_P14.get()) ln_ok = bool(self.lnclass_vars) and any(var.get() for var in self.lnclass_vars.values()) if input_ok and output_ok and device_ok and ln_ok: self.run_btn.config(state="normal") else: self.run_btn.config(state="disabled") def run_processing(self): selected_ln_classes = [ln for ln, var in self.lnclass_vars.items() if var.get()] if not selected_ln_classes: messagebox.showwarning("No selection", "No LN classes selected for deletion.") return input_file = self.input_path.get() output_file = self.output_path.get() # compute expected count from last scan expected_count = sum(self.last_ln_count.get(ln, 0) for ln in selected_ln_classes) try: self.run_btn.config(state="disabled") self.status_label.config(text="Status: Processing... please wait") self.root.update() removed_count = process_xml( input_file, self.delete_P.get(), self.delete_UR.get(), selected_ln_classes, output_file ) # final verification: removed_count should match expected_count (because scan used same logic) if removed_count == expected_count: messagebox.showinfo("Success", f"Filtering completed successfully.\n\nLN elements scanned & deleted: {removed_count}\nOutput saved to:\n{output_file}") self.status_label.config(text=f"Status: Completed — {removed_count} LN elements removed.") else: # unexpected mismatch: show both numbers to help troubleshooting messagebox.showwarning("Completed (mismatch)", f"Filtering finished, but counts differ.\n\n" f"LN elements expected to be deleted (scan sum): {expected_count}\n" f"LN elements actually deleted: {removed_count}\n\n" f"Output saved to:\n{output_file}") self.status_label.config(text=f"Status: Completed with mismatch (expected {expected_count}, removed {removed_count})") except Exception as e: messagebox.showerror("Processing Error", str(e)) self.status_label.config(text="Status: Error during processing.") finally: self.validate_run_button() # ----------------------------- # Run the application # ----------------------------- if __name__ == "__main__": root = tk.Tk() root.title("LN Filter Tool Version 1.0") app = LNFilterApp(root) root.mainloop() plz explain me